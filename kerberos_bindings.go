// Code generated by tygor; DO NOT EDIT.

package kerberos

import (
	"errors"
	"fmt"
	"github.com/dop251/goja"
	"go.k6.io/k6/js/modules"
	"time"
)

// k6Module represents k6 JavaScript extension module.
type k6Module struct {
	goModuleConstructor goModuleConstructor
}

// NewModuleInstance creates new per VU module instance.
func (m *k6Module) NewModuleInstance(vu modules.VU) modules.Instance {
	mi := new(k6ModuleInstance)
	adaptee := m.goModuleConstructor(vu)

	vm := vu.Runtime()

	dict := make(map[string]interface{})

	dict["UserClient"] = vm.ToValue(newUserClientConstructor(adaptee.newUserClient))

	mi.exports.Named = dict

	obj := vm.NewObject()

	mi.exports.Default = obj

	return mi
}

// register registers k6 JavaScript extension module.
func register(ctor goModuleConstructor) {
	m := new(k6Module)
	m.goModuleConstructor = ctor
	modules.Register("k6/x/kerberos", m)
}

// k6ModuleInstance represents per VU module instance.
type k6ModuleInstance struct {
	exports modules.Exports
}

// Exports returns exported symbols.
func (mi *k6ModuleInstance) Exports() modules.Exports {
	return mi.exports
}

// jsModule is the go binding for the JavaScript Module type.
type jsModule interface{}

// jsModuleAdapter converts goModule to jsModule.
type jsModuleAdapter struct {
	adaptee goModule
}

var _ jsModule = (*jsModuleAdapter)(nil)

// jsModuleFrom returns a jsModule based on a goModule.
func jsModuleFrom(adaptee goModule) jsModule {
	return &jsModuleAdapter{adaptee: adaptee}
}

// goModule is the go representation of the JavaScript Module type.
type goModule interface {
	// newUserClient is the go factory method for the UserClient type.
	newUserClient(configArg []byte, usernameArg string, passwordArg string, realmArg string) (goUserClient, error)
}

// goModuleConstructor creates new goModule instance.
type goModuleConstructor func(vu modules.VU) goModule

// jsToken is the go binding for the JavaScript Token type.
type jsToken interface {
	// negotiateHeaderMethod is the go binding for the JavaScript negotiateHeader method.
	negotiateHeaderMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goToken is the go representation of the JavaScript Token type.
type goToken interface {
	// negotiateHeaderMethod is the go representation of the negotiateHeader method.
	negotiateHeaderMethod() (string, error)
}

// jsTokenAdapter converts goToken to jsToken.
type jsTokenAdapter struct {
	adaptee goToken
}

var _ jsToken = (*jsTokenAdapter)(nil)

// negotiateHeaderMethod is a jsToken adapter method.
func (self *jsTokenAdapter) negotiateHeaderMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.negotiateHeaderMethod()
	if err != nil {
		panic(err)
	}

	return vm.ToValue(v)
}

// goTokenAdapter converts goja Object to goToken.
type goTokenAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goToken = (*goTokenAdapter)(nil)

// negotiateHeaderMethod is a negotiateHeader adapter method.
func (self *goTokenAdapter) negotiateHeaderMethod() (string, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("negotiateHeader"))
	if !ok {
		return "", fmt.Errorf("%w: negotiateHeader", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return "", err
	}

	return res.String(), nil
}

// jsTokenTo setup Token JavaScript object from jsToken.
func jsTokenTo(src jsToken, obj *goja.Object, vm *goja.Runtime) error {
	return obj.Set("negotiateHeader", src.negotiateHeaderMethod)
}

// jsTokenFrom returns a jsToken based on a goToken.
func jsTokenFrom(adaptee goToken) jsToken {
	return &jsTokenAdapter{adaptee: adaptee}
}

// goTokenFrom returns a goToken from goja Object.
func goTokenFrom(adaptee *goja.Object, vm *goja.Runtime) goToken {
	return &goTokenAdapter{adaptee: adaptee, vm: vm}
}

// goTokenToObject returns a goja Object from goToken.
func goTokenToObject(v goToken, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsTokenTo(jsTokenFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// jsUserClient is the go binding for the JavaScript UserClient type.
type jsUserClient interface {
	// authenticateMethod is the go binding for the JavaScript authenticate method.
	authenticateMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value
}

// goUserClient is the go representation of the JavaScript UserClient type.
type goUserClient interface {
	// authenticateMethod is the go representation of the authenticate method.
	authenticateMethod(spnArg string) (goToken, error)
}

// jsUserClientAdapter converts goUserClient to jsUserClient.
type jsUserClientAdapter struct {
	adaptee goUserClient
}

var _ jsUserClient = (*jsUserClientAdapter)(nil)

// authenticateMethod is a jsUserClient adapter method.
func (self *jsUserClientAdapter) authenticateMethod(call goja.FunctionCall, vm *goja.Runtime) goja.Value {
	v, err := self.adaptee.authenticateMethod(call.Argument(0).String())
	if err != nil {
		panic(err)
	}

	return goTokenToObject(v, vm)
}

// goUserClientAdapter converts goja Object to goUserClient.
type goUserClientAdapter struct {
	adaptee *goja.Object
	vm      *goja.Runtime
}

var _ goUserClient = (*goUserClientAdapter)(nil)

// authenticateMethod is a authenticate adapter method.
func (self *goUserClientAdapter) authenticateMethod(spnArg string) (goToken, error) {
	fun, ok := goja.AssertFunction(self.adaptee.Get("authenticate"))
	if !ok {
		return nil, fmt.Errorf("%w: authenticate", errors.ErrUnsupported)
	}

	res, err := fun(self.adaptee)
	if err != nil {
		return nil, err
	}

	return res.Export().(goToken), nil
}

// jsUserClientTo setup UserClient JavaScript object from jsUserClient.
func jsUserClientTo(src jsUserClient, obj *goja.Object, vm *goja.Runtime) error {
	return obj.Set("authenticate", src.authenticateMethod)
}

// jsUserClientFrom returns a jsUserClient based on a goUserClient.
func jsUserClientFrom(adaptee goUserClient) jsUserClient {
	return &jsUserClientAdapter{adaptee: adaptee}
}

// goUserClientFrom returns a goUserClient from goja Object.
func goUserClientFrom(adaptee *goja.Object, vm *goja.Runtime) goUserClient {
	return &goUserClientAdapter{adaptee: adaptee, vm: vm}
}

// goUserClientToObject returns a goja Object from goUserClient.
func goUserClientToObject(v goUserClient, vm *goja.Runtime) *goja.Object {
	obj := vm.NewObject()

	err := jsUserClientTo(jsUserClientFrom(v), obj, vm)
	if err != nil {
		panic(err)
	}

	return obj
}

// goUserClientConstructor creates new goUserClient instance.
type goUserClientConstructor func(configArg []byte, usernameArg string, passwordArg string, realmArg string) (goUserClient, error)

// newUserClientConstructor creates UserClient JavaScript constructor.
func newUserClientConstructor(ctor goUserClientConstructor) func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
	return func(call goja.ConstructorCall, vm *goja.Runtime) *goja.Object {
		adaptee, err := ctor((call.Argument(0).Export().(goja.ArrayBuffer)).Bytes(), call.Argument(1).String(), call.Argument(2).String(), call.Argument(3).String())
		if err != nil {
			panic(err)
		}

		adapter := jsUserClientFrom(adaptee)

		if err := jsUserClientTo(adapter, call.This, vm); err != nil {
			panic(err)
		}

		return nil
	}
}
func goTimeFromDate(v goja.Value, vm *goja.Runtime) time.Time {
	getTime, ok := goja.AssertFunction(v.ToObject(vm).Get("getTime"))
	if !ok {
		panic(fmt.Errorf("%w: getTime", errors.ErrUnsupported))
	}

	ret, err := getTime(v)
	if err != nil {
		panic(err)
	}

	return time.UnixMilli(ret.ToInteger())
}

func jsDateFromTime(t time.Time, vm *goja.Runtime) goja.Value {
	d, err := vm.New(vm.Get("Date"), vm.ToValue(t.UnixMilli()))
	if err != nil {
		panic(err)
	}

	return d
}
